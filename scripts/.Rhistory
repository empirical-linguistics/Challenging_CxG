# add column with acceptance rate - see ?count for more info
papers %>% mutate(decision_binary = ifelse(decision %in% c("paper", "poster"), "accept", "reject")) %>%
group_by(country) %>%
add_count(decision_binary) %>%
add_count(name = "n_all") %>%
mutate(rel = n/n_all) %>%
ggplot(aes(group = decision, x = fct_reorder(country, rel, .desc = TRUE), fill = decision)) +
geom_bar(position = "fill") + scale_fill_viridis_d(begin = .8, end = .1) +
ggtitle("Conference paper decisions by country") +
geom_text(stat = "count", aes(label = after_stat(count), color = decision), position = position_fill(vjust = .5)) +
scale_color_manual(values = c("black", "white", "white")) +
guides(color = "none") +
guides(fill = guide_legend(title = "Decision")) +
theme(plot.title = element_text(face = "bold", hjust = 0.5)) +
xlab("Country") + ylab("Relative Frequency") +
scale_y_continuous(labels = percent)
# add column with acceptance rate - see ?count for more info
papers %>% mutate(decision_binary = ifelse(decision %in% c("paper", "poster"), "accept", "reject")) %>%
group_by(country) %>%
add_count(decision_binary) %>%
add_count(name = "n_all") %>%
mutate(rel = n/n_all)
# add column with acceptance rate - see ?count for more info
papers %>% mutate(decision_binary = ifelse(decision %in% c("paper", "poster"), "accept", "reject")) %>%
group_by(country) %>%
add_count(decision_binary) %>%
add_count(name = "n_all") %>%
mutate(rel = n/n_all) %>% unique
# add column with acceptance rate - see ?count for more info
papers %>% mutate(decision_binary = ifelse(decision %in% c("paper", "poster"), "accept", "reject")) %>%
group_by(country) %>%
add_count(decision_binary) %>%
add_count(name = "n_all") %>%
mutate(rel = n/n_all) %>%
ggplot(aes(group = decision, x = fct_reorder(country, rel), fill = decision)) +
geom_bar(position = "fill") + scale_fill_viridis_d(begin = .8, end = .1) +
ggtitle("Conference paper decisions by country") +
geom_text(stat = "count", aes(label = after_stat(count), color = decision), position = position_fill(vjust = .5)) +
scale_color_manual(values = c("black", "white", "white")) +
guides(color = "none") +
guides(fill = guide_legend(title = "Decision")) +
theme(plot.title = element_text(face = "bold", hjust = 0.5)) +
xlab("Country") + ylab("Relative Frequency") +
scale_y_continuous(labels = percent)
library(tidyverse)
library(beeswarm)
library(ggbeeswarm)
library(scales)
library(patchwork)
# load example dataset
data(cars) # see ?cars for info
ggplot(cars,          # the dataset
aes(            # IMPORTANT: the aesthetic mappings, i.e. the
x = speed,  # mappings between data and visual properties,
y = dist         # have to be wrapped in aes()!
)) +
geom_point()       # a geom object that describes
p1 <- ggplot(cars,
aes(
x = speed,
y = dist
)) +
geom_point()
# add a regression line:
(p1 <- p1 +
geom_smooth(method = "lm") )
# change appearance of x axis:
# (just for illustrative purposes, doesn't make sense here)
p1 + scale_x_continuous(breaks = seq(0,25,7))
# log-transform y axis (also just for demonstraion):
p1 + scale_y_continuous(trans = "log2")
# with the scale_ arguments, we can change the
# aesthetic mappings specified via aes(). Why does this
# not work?
p1 + scale_color_manual(values = "red")
# Because we haven't specified color in the aesthetic
# mappings. We could do so:
(p1 <- p1 + geom_point(aes(color = "bla")))
(p1 <- p1 + scale_color_manual(values = "red"))
# remove legend:
(p1 <- p1 + guides(col = "none"))
# we can also customize x and y labels by adding
# the respective layers
(p1 <- p1 + xlab("Speed") + ylab("Dist"))
# ... and add a title:
(p1 <- (p1 + ggtitle("Cars")))
# ... and customize the title, e.g.
# to make it boldface and center it:
(p1 <- p1 + theme(plot.title = element_text(face = "bold",
hjust = 0.5)))
# we can also change the theme:
p1 + theme_bw()
p1 + theme_minimal()
# or remove or cutomize the gridlines:
p1 + theme(panel.grid.minor = element_blank())
p1 + theme(panel.grid.major = element_blank())
p1 + theme(panel.grid = element_blank())
p1 + theme(panel.grid.major.x =  element_blank(),
panel.grid.minor.x = element_blank())
# example dataset: WWWusage
data("WWWusage")
# ggplot only accepts dataframes as input,
# so we first have to build a dataframe:
wwwusage <- tibble(time = 1:100,
WWWusage = WWWusage)
# now try building the plot yourself!
# Hint: the relevant geom is geom_line().
ggplot(wwwusage, aes(x = time, y = WWWusage)) +
geom_point() +
geom_line(lwd=1.5)
# fake dataset:
# set a seed for replicability
set.seed(utf8ToInt("ascona"))
# get a sample
spl <- LETTERS[round(rnorm(200, mean = 7, sd = 2))]
# again, remember that ggplot usually only accepts
# dataframes as input. One thing we can do is just
# creating a one-column dataframe with our spl data
# from above:
tibble(x = spl) %>%
ggplot(aes(x = x)) +
geom_bar() # barplot
# alternatively, we can use tabulated data
# with geom_col():
tbl <- table(spl) %>% sort(decreasing = T)
tbl <- as_tibble(tbl)
# now we can use this as input for geom_col:
colnames(tbl)
ggplot(tbl, aes(x = spl,  # x axis
y = n)) + # y axis
geom_col() # same result as before.
# add a group variable to spl: letters from A-E vs. letters
# from F-K
spl01 <- tibble(letters = spl)
spl01$group <- ifelse(spl01$letters %in% LETTERS[1:5], "A-E", "F-K")
# plot:
spl01 %>%
ggplot(aes(x = group, fill = letters)) +
geom_bar() +
scale_fill_viridis_d() # colorblind-friendly palette
# we can also add labels:
spl01 %>%
ggplot(aes(x = group, fill = letters)) +
geom_bar() +
scale_fill_viridis_d() +
geom_text(stat="count", # necessary to compute y axis position
# (horribly counterintuitive, I know!!)
aes(label = letters),
position = position_stack(vjust = .5),
col = c(rep("white", 5), rep("black", 6))) + # specify color of text
guides(fill = "none") # remove legend
# using proportions:
(p <-spl01 %>%
ggplot(aes(x = group, fill = letters)) +
geom_bar(position = "fill") +
scale_fill_viridis_d() +
scale_y_continuous(labels = percent) ) # requires package "scales"!
# add labels:
p + geom_text(stat="count",
aes(label = after_stat(count)),
position = position_fill(vjust = .5))
p + geom_text(stat="count",
aes(label = after_stat(count),
color = letter),
position = position_fill(vjust = .5))
p + geom_text(stat="count",
aes(label = after_stat(count),
color = letters),
position = position_fill(vjust = .5))
p + geom_text(stat="count",
aes(label = after_stat(count),
color = letters),
position = position_fill(vjust = .5)) +
scale_color_manual(values = c(rep("white", 4), rep("black", 7)))
p + geom_text(stat="count",
aes(label = after_stat(count),
color = letters),
position = position_fill(vjust = .5)) +
scale_color_manual(values = c(rep("white", 4), rep("black", 7))) +
guides(color = "none")
# create a dataframe with random data
set.seed(utf8ToInt("ascona"))
d <- data.frame(x = 1:10,
y = sample(1:100, 10))
head(d)
# first try:
ggplot(d, aes(x = x,
y = y)) + geom_beeswarm()
d <- pivot_longer(d, cols = c("x", "y"))
d
# replace the names:
colnames(d) <- c("group", "value")
# now let's try again:
ggplot(d, aes(x = group, y = value)) +
geom_beeswarm()
(p <- ggplot(d, aes(x = group, y = value)) +
geom_beeswarm(col = "blue"))
# add boxplot:
p + geom_boxplot(fill = "grey", alpha = .3)
# or a violin plot:
p + geom_violin(alpha = .3)
# We can use ggsave to save ggplots - uncomment ggsave below to use:
p + geom_violin(alpha = .3)
p | p1
p + theme(text = element_text(size = 18),
title = element_text(size = 18))
p + theme(text = element_text(size = 18),
title = element_text(size = 18)) +
theme_bw() # font size change is lost
# generate data
country <- c(rep("Germany", 25), rep("USA", 21), rep("UK", 40),
rep("China", 10), rep("Switzerland", 2), rep("Kazakhstan", 1),
rep("South Africa", 1))
decision <- c(rep("paper", 20), rep("poster", 3), rep("reject", 2),
rep("paper", 15), rep("poster", 4), rep("reject", 2),
rep("paper", 32), rep("poster", 4), rep("reject", 4),
rep("paper", 3), rep("poster", 3), rep("reject", 4),
rep("paper", 1), rep("reject", 1),
rep("paper", 1), rep("poster", 1))
# combine data in a dataframe
papers <- tibble(country = country, decision = decision)
papers$decision <- factor(papers$decision, levels = rev(c("reject", "poster", "paper")))
# plot data
ggplot(papers, aes(group = decision, x = country, fill = decision)) +
geom_bar(position = "fill") + scale_fill_viridis_d(begin = .8, end = .1) +
ggtitle("Conference paper decisions by country") +
geom_text(stat = "count", aes(label = after_stat(count), color = decision), position = position_fill(vjust = .5)) +
scale_color_manual(values = c("black", "white", "white")) +
guides(color = "none") +
guides(fill = guide_legend(title = "Decision")) +
theme(plot.title = element_text(face = "bold", hjust = 0.5)) +
xlab("Country") + ylab("Relative Frequency") +
scale_y_continuous(labels = percent)
# add column with acceptance rate - see ?count for more info
papers %>% mutate(decision_binary = ifelse(decision %in% c("paper", "poster"), "accept", "reject")) %>%
group_by(country) %>%
add_count(decision_binary) %>%
add_count(name = "n_all") %>%
mutate(rel = n/n_all) %>%
ggplot(aes(group = decision, x = fct_reorder(country, rel), fill = decision)) +
geom_bar(position = "fill") + scale_fill_viridis_d(begin = .8, end = .1) +
ggtitle("Conference paper decisions by country") +
geom_text(stat = "count", aes(label = after_stat(count), color = decision), position = position_fill(vjust = .5)) +
scale_color_manual(values = c("black", "white", "white")) +
guides(color = "none") +
guides(fill = guide_legend(title = "Decision")) +
theme(plot.title = element_text(face = "bold", hjust = 0.5)) +
xlab("Country") + ylab("Relative Frequency") +
scale_y_continuous(labels = percent)
nettle <- read_csv("../data/language_diversity.csv")
nettle
nettle$Measurement
str(nettle)
nettle$Measurement
# pivot wider
nettle %>%
pivot_wider(id_cols = c("Continent", "Country"))
View(nettle)
# pivot wider
nettle %>%
pivot_wider(id_cols = list("Continent", "Country"))
?pivot_wider
# pivot wider
nettle %>%
pivot_wider(values_from = 2:4)
# pivot wider
nettle %>%
pivot_wider(values_from = 3:4)
# pivot wider
nettle %>%
pivot_wider(names_from = Measurement, values_from = Value)
# pivot wider
nettle <- nettle %>%
pivot_wider(names_from = Measurement, values_from = Value)
# plot MGS and number of languages
ggplot(nettle, aes(x = MGS, y = Langs)) +
geom_point()
# plot MGS and number of languages
ggplot(nettle, aes(x = MGS, y = Langs)) +
geom_point() +
geom_smooth()
# plot MGS and number of languages
ggplot(nettle, aes(x = MGS, y = Langs, group = Continent)) +
geom_point() +
geom_smooth()
# plot MGS and number of languages
ggplot(nettle, aes(x = MGS, y = Langs, group = Continent, fill = Continent)) +
geom_point() +
geom_smooth()
# plot MGS and number of languages
ggplot(nettle, aes(x = MGS, y = Langs)) +
geom_point() +
geom_smooth()
# plot MGS and number of languages
ggplot(nettle, aes(x = MGS, y = Langs)) +
geom_point() +
geom_smooth() +
facet_wrap(~Continent)
# plot MGS and number of languages
ggplot(nettle, aes(x = MGS, y = Langs)) +
geom_point() +
# geom_smooth() +
facet_wrap(~Continent)
# plot MGS and number of languages
ggplot(nettle, aes(x = MGS, y = Langs)) +
geom_point() +
# geom_smooth() +
facet_wrap(~Continent, ncol = 4)
dpois(100, 10)
dpois(10, 10)
ppois(100, 10)
rpois(100, 10)
rpois(100, 10) %>% table
rpois(1, 10) %>% table
rpois(200, 10) %>% table
rpois(200, 1) %>% table
rpois(200, 2) %>% table
rpois(200, 3) %>% table
ppois(0, 10)
ppois(0, 1)
ppois(0, 100)
ppois(0, 1)
ppois(0, 10)
rpois(200, 3) %>% table
ppois(0,100)
library(tidyverse)
library(glmmTMB)
library(MASS)
library(pscl)
library(effects)
library(vcd)
library(car)
library(readxl)
########################
# Modeling count data  #
########################
# libraries ---------------------------------------------------------------
library(tidyverse)
library(glmmTMB)
library(MASS)
library(pscl)
library(effects)
library(vcd)
library(car)
library(readxl)
# fake data ---------------------------------------------------------------
# (adapted from https://aosmith.rbind.io/2019/03/06/lots-of-zeros/)
# simulate data with a single, continuous independent variable
set.seed(16)
x <- runif(200, 2, 10) # simulate explanatory variable
b0 <- 1 # set value of intercept
b1 <- 0.25 # set value of slope
means <- exp(b0 + b1*x) # calculate true means
theta <- 0.25 # true theta
# simulate data from the negative binomial distribution
y <- rnbinom(200, mu = means, size = theta)
# fit negative binomial model
fit1 <- glm.nb(y ~ x)
# check for excess zeros:
# how many zeros are in the data?
sum(y == 0)
# How many zeros does the model predict?
preds <- predict(fit1, type = "response") # estimated means
esttheta <- summary(fit1)$theta # estimated theta
prop0 <- dnbinom(x = 0, mu = preds, size = esttheta )
round(sum(prop0))
# fit Poisson model instead
fit2 <- glm(y ~ x, family = poisson)
sum(y == 0)
# how many zeros does the model predict?
round( sum( dpois(x = 0,
lambda = predict(fit2, type = "response") ) ) )  # 0!
# fake data ---------------------------------------------------------------
set.seed(utf8ToInt("Ascona"))
counts <- rpois(100, lambda = 2)
counts
counts2 <- rpois(100, lambda = 1)
tibble(category = c(rep("A", 100), rep("B", 200)),
count = c(counts, counts2))
c(counts, counts2)
c(rep("A", 100), rep("B", 200)
)
tibble(category = c(rep("A", 100), rep("B", 100)),
count = c(counts, counts2))
df <- tibble(category = c(rep("A", 100), rep("B", 100)),
count = c(counts, counts2))
# plot
ggplot(df, aes(x = category, y = count)) +
geom_boxplot()
# plot
ggplot(df, aes(x = category, y = count)) +
geom_jitter() +
geom_boxplot()
library(ggbeeswarm)
# plot
ggplot(df, aes(x = category, y = count)) +
geom_beeswarm() +
geom_boxplot(alpha = .5)
# plot
ggplot(df, aes(x = category, y = count)) +
geom_beeswarm() +
geom_boxplot(alpha = .5, notch = T)
# plot
ggplot(df, aes(x = category, y = count)) +
geom_beeswarm() +
geom_violin()
# plot
ggplot(df, aes(x = category, y = count)) +
geom_beeswarm()
# plot
ggplot(df, aes(x = category, y = count)) +
geom_boxplot()
# model
glm(count ~ category, family = "poisson", data = df)
# model
m <- glm(count ~ category, family = "poisson", data = df)
summary(m)
plot(allEffects(m))
# how many zeros does the model predict?
predict(m, type = "response")
# how many zeros does the model predict?
myfir <- predict(m, type = "response")
# how many zeros does the model predict?
myfit <- predict(m, type = "response")
rm(myfir)
summary(myfit)$theta
summary(myfit)
myfit
rm(myfit)
# how many zeros does the model predict?
predict(m)
# how many zeros does the model predict?
predict(m, type = "response")
?dpois
# how many zeros does the model predict?
dpois(x=0, lambda = predict(m, type = "response"))
# how many zeros does the model predict?
sum(dpois(x=0, lambda = predict(m, type = "response")))
predict(m, type = "response")
predict(m, type = "response")[1]
predict(m, type = "response")[2]
predict(m, type = "response")[3]
predict(m, type = "response")
sum(dpois(x=0, lambda = predict(m, type = "response")))
?predict
# The predict() function returns the means that
# the model estimates.
preds <- predict(m, type = "response")
preds
# the density distribution function (for Poisson: dpois)
# returns the probability that the observation
# is equal to a given value, given the current
# lambda value.
sum(dpois(x=0, lambda = preds))
preds
m$model$count
m$data$count
plot(m$model$count,m$data$count)
# calculate Pearson chisquare
pr <- resid(m, type = "pearson")
pchi2 <- sum(residuals(m, type="pearson")Ë†2)
pchi2 <- sum(residuals(m, type="pearson")^2)
pchi2
disp <- pchi2/m$df.residual; pchi2; disp
pchi2; disp
d <- read_csv("../data/nettle_1999_climate.csv")
m1 <- glm(Langs ~ MGS, data = d)
allEffects(m1)
plot(allEffects(m1))
pr <- resid(m1, type = "pearson") # residuals
pchi2 <- sum(residuals(m1, type="pearson")^2) #Pearson chi-squared
disp <- pchi2/m1$df.residual # Pearson disperson statistic
pchi2; disp
# also check for zero-inflation:
# how many 0s does the model predict?
preds <- predict(m1, type = "response")
sum(dpois(x=0, lambda = preds))
sum(dpois(x=0, lambda = preds)) %>% round
# how many zeros are in the dataset?
d$Langs
# how many zeros are in the dataset?
which(d$Langs==0)
# how many zeros are in the dataset?
which(d$Langs==0)
?glm
library(VGAM)
?pospoisson
# zero-truncated Poisson model:
m2 <- vglm(Langs ~ MGS, data = d)
# zero-truncated Poisson model:
m2 <- vglm(Langs ~ MGS, data = d, family = "pospoisson")
# zero-truncated Poisson model:
m2 <- vglm(Langs ~ MGS, data = d, family = pospoisson())
# zero-truncated Poisson model:
m2 <- vglm(Langs ~ MGS, family = pospoisson(),
data = d)
vglm
# zero-truncated Poisson model:
m2 <- vglm(Langs ~ MGS, family = pospoisson(),
data = d)
# zero-truncated Poisson model:
m2 <- vglm(Langs ~ MGS, family = pospoisson,
data = d)
# zero-truncated Poisson model:
m2 <- vglm(Langs ~ MGS, family = posnegbinomial(),
data = d)
summary(m2)
# plot MGS and number of languages
ggplot(nettle, aes(x = MGS, y = Langs)) +
geom_point() +
# geom_smooth() +
facet_wrap(~Continent, ncol = 4)
