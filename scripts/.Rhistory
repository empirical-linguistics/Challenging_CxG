library(tidyverse)
library(beeswarm)
library(ggbeeswarm)
library(scales)
library(patchwork)
?cars
# simple scatterplot
data("cars") # example dataset, see ?cars for information
plot(x = cars$speed, y = cars$dist)
plot(x = cars$speed,    # x axis
y = cars$dist,     # y axis
pch = 20,          # optional: change point type
col = "blue",      # optional: change color
xlab = "speed",    # x axis label
ylab = "distance") # y axis label
abline(lm(cars$dist~cars$speed), # add regression line
col = "grey",                # color
lty = 2)                     # line type (2 = dashed)
d <- data.frame(x = 1:10,
y = sample(1:100, 10))
plot(d$x, d$y, ylim = c(0, max(d$y)))
title("Some plot")
title("Cars")           # add title
data("WWWusage")
plot(1:100, WWWusage, type = "l", xlab="Time",
main = "WWW usage per minute")
# we can also combine dotplot and lineplot:
plot(1:100, # x axis
WWWusage, # y axis
type = "p", # p = points
xlab="Time", # x axis label
pch = 20, # change point type
col = rgb(0,0,1,.25), # RGB: red, green, blue + alpha (= transparency)
ylim = c(0,250),  # y axis limits
main = "WWW usage per minute", cex=2, cex.axis=3, cex.main=3, cex.lab=3)
points(x=20,y=150, col="red")
text(x=80,y=200, "hi", cex=3)
lines(1:100, WWWusage,
type = "l", # l = line
col = rgb(.256,.256,.256,.5), # RGB code for grey (+ alpha)
lwd = 4)
# we can also add a grid:
grid(nx = 0, # no grid lines on x axis
ny = NULL, # NULL here means that grid aligns with tick marks
# (see vignette: ?grid)
lty = 1, col = "grey90")
# set a seed for replicability
set.seed(utf8ToInt("lotwinterschool"))
# get a sample
spl <- LETTERS[round(rnorm(200, mean = 5, sd = 2))]
data(cars)
ggplot(cars,          # the dataset
aes(           # IMPORTANT: the aesthetic mappings, i.e. the
x = speed, # mappings between data and visual properties,
y = dist         # have to be wrapped in aes()!
)) +
geom_point()     # a geom object that describes
p1 <- ggplot(cars,
aes(
x = speed,
y = dist
)) +
geom_point()
# add a regression line:
(p1 <- p1 +
geom_smooth(method = "lm") )
# change appearance of x axis:
# (just for illustrative purposes, doesn't make sense here)
p1 + scale_x_continuous(breaks = seq(0,25,7))
# log-transform y axis (also just for demonstraion):
p1 + scale_y_continuous(trans = "log2")
# with the scale_ arguments, we can change the
# aesthetic mappings specified via aes(). Why does this
# not work?
p1 + scale_color_manual(values = "red")
# Because we haven't specified color in the aesthetic
# mappings. We could do so:
(p1 <- p1 + geom_point(aes(color = "bla")))
(p1 <- p1 + scale_color_manual(values = "red"))
# remove legend:
(p1 <- p1 + guides(col = "none"))
# we can also customize x and y labels by adding
# the respective layers
(p1 <- p1 + xlab("Speed") + ylab("Dist"))
# ... and add a title:
(p1 <- (p1 + ggtitle("Cars")))
# ... and customize the title, e.g.
# to make it boldface and center it:
(p1 <- p1 + theme(plot.title = element_text(face = "bold",
hjust = 0.5)))
# we can also change the theme:
p1 + theme_bw()
p1 + theme_minimal()
# or remove or cutomize the gridlines:
p1 + theme(panel.grid.minor = element_blank())
p1 + theme(panel.grid.major = element_blank())
p1 + theme(panel.grid = element_blank())
p1 + theme(panel.grid.major.x =  element_blank(),
panel.grid.minor.x = element_blank())
# example dataset: WWWusage
data("WWWusage")
# ggplot only accepts dataframes as input,
# so we first have to build a dataframe:
wwwusage <- tibble(time = 1:100,
WWWusage = WWWusage)
# now try building the plot yourself!
# Hint: the relevant geom is geom_line().
ggplot(wwwusage, aes(x = time, y = WWWusage)) +
geom_point() +
geom_line(lwd=1.5)
# again, remember that ggplot usually only accepts
# dataframes as input. One thing we can do is just
# creating a one-column dataframe with our spl data
# from above:
tibble(x = spl) %>%
ggplot(aes(x = x)) +
geom_bar() # barplot
# alternatively, we can use the already tabulated data
# with geom_col():
tbl <- as_tibble(tbl)
# fake dataset:
# set a seed for replicability
set.seed(utf8ToInt("ascona"))
# get a sample
spl <- LETTERS[round(rnorm(200, mean = 5, sd = 2))]
# get a sample
spl <- LETTERS[round(rnorm(200, mean = 7, sd = 2))]
# fake dataset:
# set a seed for replicability
set.seed(utf8ToInt("ascona"))
# get a sample
LETTERS[round(rnorm(200, mean = 7, sd = 2))]
# fake dataset:
# set a seed for replicability
set.seed(utf8ToInt("ascona"))
# get a sample
spl <- LETTERS[round(rnorm(200, mean = 7, sd = 2))]
# again, remember that ggplot usually only accepts
# dataframes as input. One thing we can do is just
# creating a one-column dataframe with our spl data
# from above:
tibble(x = spl) %>%
ggplot(aes(x = x)) +
geom_bar() # barplot
# alternatively, we can use the already tabulated data
# with geom_col():
tbl <- as_tibble(tbl)
# alternatively, we can use tabulated data
# with geom_col():
tbl <- table(spl) %>% sort(decreasing = T)
tbl <- as_tibble(tbl)
# now we can use this as input for geom_col:
colnames(tbl)
ggplot(tbl, aes(x = spl,  # x axis
y = n)) + # y axis
geom_col() # same result as before.
# add a group variable to spl: letters from A-E vs. letters
# from F-K
spl01 <- tibble(letters = spl)
spl01$group <- ifelse(spl01$letters %in% LETTERS[1:5], "A-E", "F-K")
# plot:
spl01 %>%
ggplot(aes(x = group, fill = letters)) +
geom_bar() +
scale_fill_viridis_d() # colorblind-friendly palette
# we can also add labels:
spl01 %>%
ggplot(aes(x = group, fill = letters)) +
geom_bar() +
scale_fill_viridis_d() +
geom_text(stat="count", # necessary to compute y axis position
# (horribly counterintuitive, I know!!)
aes(label = letters),
position = position_stack(vjust = .5),
col = c(rep("white", 5), rep("black", 6))) + # specify color of text
guides(fill = "none") # remove legend
# using proportions:
(p <-spl01 %>%
ggplot(aes(x = group, fill = letters)) +
geom_bar(position = "fill") +
scale_fill_viridis_d() +
scale_y_continuous(labels = percent) ) # requires package "scales"!
# add labels:
p + geom_text(stat="count",
aes(label = after_stat(count)),
position = position_fill(vjust = .5))
# we use the d dataframe again that
# we created above.
head(d)
# first try:
ggplot(d, aes(x = x,
y = y)) + geom_beeswarm()
# create a dataframe with random data
set.seed(utf8ToInt("ascona"))
d <- data.frame(x = 1:10,
y = sample(1:100, 10))
head(d)
# first try:
ggplot(d, aes(x = x,
y = y)) + geom_beeswarm()
d <- pivot_longer(d, cols = c("x", "y"))
d
# replace the names:
colnames(d) <- c("group", "value")
# now let's try again:
ggplot(d, aes(x = group, y = value)) +
geom_beeswarm()
(p <- ggplot(d, aes(x = group, y = value)) +
geom_beeswarm(col = "blue"))
# add boxplot:
p + geom_boxplot(fill = "grey", alpha = .3)
# or a violin plot:
p + geom_violin(alpha = .3)
# We can use ggsave to save ggplots:
p + geom_violin(alpha = .3)
p | p1
p + theme(text = element_text(size = 18),
title = element_text(size = 18))
p + theme(text = element_text(size = 18),
title = element_text(size = 18)) +
theme_bw() # font size change is lost
# libraries ---------------------------------------------------------------
library(tidyverse)
library(glmmTMB)
library(MASS)
d <- read_csv("../data/nettle_1999_climate.csv")
d
glm.nb(Langs ~ MGS + offset(Area), data = d)
m <- glm.nb(Langs ~ MGS + offset(Area), data = d)
m <- glm.nb(Langs ~ MGS + offset(Area), data = d)
summary(m)
library(pscl)
wizard::qbarplot(d, Langs, MGS)
d
ggplot(d, aes(x = Langs, y = MGS)) +
geom_point()
ggplot(d, aes(x = MGS, y = Langs)) +
geom_point()
ggplot(d, aes(x = MGS, y = Langs)) +
geom_point() + geom_smooth()
ggplot(d, aes(x = MGS, y = Langs)) +
geom_point() + geom_smooth(method = "poisson")
ggplot(d, aes(x = MGS, y = Langs)) +
geom_point() + geom_smooth(method = "Poisson")
ggplot(d, aes(x = MGS, y = Langs)) +
geom_point() + geom_smooth(method = "poisson")
?geom_smooth
ggplot(d, aes(x = MGS, y = Langs)) +
geom_point() + geom_smooth(method = MASS::glm.nb())
ggplot(d, aes(x = MGS, y = Langs)) +
geom_point() + geom_smooth(method = MASS::glm.nb)
library(effects)
# plot model coefficients
plot(allEffects(m))
# plot model coefficients
allEffects(m)
# plot model coefficients
str(m)
# plot model coefficients
coef(m)
# compare with model without MGS
m0 <- update(m, .~., -MGS)
anova(m, m2)
anova(m, m0)
# compare with model without MGS
m0 <- glm.nb(Langs ~ 1 + offset(Area), data = d)
anova(m, m0)
glm(Langs ~ MGS + offset(Area), family = "poisson", data = d)
m_pois <- glm(Langs ~ MGS + offset(Area), family = "poisson", data = d)
pchisq(2*(logLik(m) - logLik(m_pois)), df = 1, lower.tail = F)
pchisq(2*(logLik(m) - logLik(m_pois)), lower.tail = F)
pchisq(2*(logLik(m) - logLik(m_pois)), df = 2, lower.tail = F)
pchisq(2*(logLik(m) - logLik(m_pois)), df = 1, lower.tail = F)
pchisq(2*(logLik(m) - logLik(m_pois)), df = 1, lower.tail = F)
?pchisq
logLik(m1)
logLik(m)
logLik(m3)
logLik(m_pois)
2*(logLik(m) - logLik(m_pois)
)
# estimated chi-squared value:
2*(logLik(m) - logLik(m_pois))
pchisq(2*(logLik(m) - logLik(m_pois)), df = 3, lower.tail = F)
# estimated chi-squared value:
2*(logLik(m) - logLik(m_pois))
library(vcd)
# observed vs. fitted frequencies
fit <- goodfit(d$Langs, type = "nbinomial")
summary(fit)
rootogram(fit)
Ord_plot(d$Langs)
Ord_plot(d$Langs, type = "nbinomial")
plot(1:10)
Ord_plot(d$Langs, type = "nbinomial")
anova(m, test = "Chisq")
library(car)
# check for influential datapoints
influencePlot(m)
# simulate days on which the monks drink
set.seed(365)
drink <- rbinom(N, 1, prob_drink)
# sample one year of production
N <- 365
drink <- rbinom(N, 1, prob_drink)
# define parameters
prob_drink <- 0.2 # 20% of days
rate_work <- 1 # average 1 manuscript per day
# sample one year of production
N <- 365
# simulate days on which the monks drink
set.seed(365)
drink <- rbinom(N, 1, prob_drink)
# simulate number of completed manuscripts
y <- (1-drink)*rpois(N, rate_work)
y
# visualize
hist(y)
table(y)
table(y) %>% hist
table(y) %>% hist()
table(y) %>% barplot()
drink
y
1-drink
# zero-inflated Poisson model
tibble(drink = drink,
manuscripts = y)
# zero-inflated Poisson model
monks <- tibble(drink = drink,
manuscripts = y)
zeroinfl(manuscripts ~ drink, data = monks)
m_monks <- zeroinfl(manuscripts ~ drink, data = monks)
summary(m_monks)
m_monks <- zeroinfl(manuscripts ~ factor(drink), data = monks)
summary(m_monks)
monks$manuscripts
ggplot(monks, aes(x = manuscripts)) + geom_col()
ggplot(monks, aes(x = manuscripts)) + geom_bar()
ggplot(monks, aes(x = manuscripts, group = drink)) + geom_bar()
ggplot(monks, aes(x = manuscripts, fill = drink)) + geom_bar()
ggplot(monks, aes(x = manuscripts, fill = drink, group = drink)) + geom_bar()
ggplot(monks, aes(x = manuscripts, fill = drink, group = drink)) + geom_bar(position = "dodge")
ggplot(monks, aes(x = manuscripts, fill = drink, group = factor(drink))) + geom_bar(position = "dodge")
ggplot(monks, aes(x = manuscripts, fill = factor(drink), group = factor(drink))) + geom_bar(position = "dodge")
library(readxl)
dat <- read_xlsx("../data/errors_data.xlsx")
dat
dat$Kategorie_fein
dat$Kategorie_fein %>% unique
dat$BS_fin
dat$Kategorie_fein
dat$Kategorie_fein %>% unique
# English names for categories
d_tbl$Category <- case_when(d_tbl$Kategorie_grob=="Stamm" ~ "Stem",
d_tbl$Kategorie_grob=="Derivation" ~ "Derivation",
d_tbl$Kategorie_grob=="Flexion" ~ "Inflection")
# English names for categories
dat$Category <- case_when(dat$Kategorie_grob=="Stamm" ~ "Stem",
dat$Kategorie_grob=="Derivation" ~ "Derivation",
dat$Kategorie_grob=="Flexion" ~ "Inflection")
dat$`Kategorie grob`
# improve column names
gsub(" ", "_", colnames(dat))
# improve column names
colnames(dat) <- gsub(" ", "_", colnames(dat))
# English names for categories
dat$Category <- case_when(dat$Kategorie_grob=="Stamm" ~ "Stem",
dat$Kategorie_grob=="Derivation" ~ "Derivation",
dat$Kategorie_grob=="Flexion" ~ "Inflection")
dat$Category <- factor(dat$Category, levels = c("Stem", "Derivation", "Inflection"))
# visualize
ggplot(dat, aes(x = Category)) + geom_bar()
table(dat$Fehler)
set.seed(16)
x = runif(200, 5, 10) # simulate explanatory variable
b0 = 1 # set value of intercept
b1 = 0.25 # set value of slope
means = exp(b0 + b1*x) # calculate true means
theta = 0.25 # true theta
# simulate data from the negative binomial distribution
y = rnbinom(200, mu = means, size = theta)
# simulate data from the negative binomial distribution
y <- rnbinom(200, mu = means, size = theta)
y
hist(y)
# fit negative binomial model
fit1 <- glm.nb(y ~ x)
# check for excess zeros
sum(y == 0)
# How many zeros does the model predict?
preds <- predict(fit1, type = "response") # estimated means
esttheta <- summary(fit1)$theta # estimated theta
prop0 = dnbinom(x = 0, mu = preds, size = esttheta )
round(sum(prop0))
# fit Poisson model instead
fit2 <- glm(y ~ x, family = poisson)
sum(y == 0)
# how many zeros does the model predict?
round( sum( dpois(x = 0,
lambda = predict(fit2, type = "response") ) ) )
set.seed(1985)
random_pois <- rpois(n = 2000, lambda = 10)
random_pois
random_pois <- lapply(1:100, function(i) rpois(n = 200, lambda = 10))
set.seed(1985)
random_pois <- lapply(1:100, function(i) rpois(n = 200, lambda = 10))
random_pois
library(shiny); runApp('~/sciebo/Projekte/Ascona Challenging CxG/data/distribution_graphs.R')
runApp('~/sciebo/Projekte/Ascona Challenging CxG/data/distribution_graphs.R')
runApp('~/sciebo/Projekte/Ascona Challenging CxG/data/distribution_graphs.R')
?dpois
dpois(1:200)
dpois(1:200, lambda = 20)
dpois(1:200, lambda = 20) %>% sd
dpois(1:200, lambda = 20) %>% var
dpois(1:200, lambda = 20) %>% var %>% round()
dpois(1:200, lambda = 20) %>% var %>% round(digits = 4)
runApp('~/sciebo/Projekte/Ascona Challenging CxG/data/distribution_graphs.R')
runApp('~/sciebo/Projekte/Ascona Challenging CxG/data/distribution_graphs.R')
runApp('~/sciebo/Projekte/Ascona Challenging CxG/data/distribution_graphs.R')
runApp('~/sciebo/Projekte/Ascona Challenging CxG/data/distribution_graphs.R')
runApp('~/sciebo/Projekte/Ascona Challenging CxG/data/distribution_graphs.R')
runApp('~/sciebo/Projekte/Ascona Challenging CxG/data/distribution_graphs.R')
runApp('~/sciebo/Projekte/Ascona Challenging CxG/data/distribution_graphs.R')
library(tidyverse)
set.seed(1985)
a1 <- rnorm(200, mean = 20, sd = 2)
a2 <- rpois(200, 25)
library(zipfR)
?zipfR
a3 <- rnorm(200, mean = 20, sd = 2)^3
mean(a3)
mean(a3)/800
mean(a3)/400
a3 <- round(a3/400)
library(patchwork)
a <- tibble(a1 = a1, a2 = a2, a3 = a3)
a
pivot_longer(a, cols = 1:3)
a <- pivot_longer(a, cols = 1:3)
ggplot(a, aes(x = value, fill = name)) + geom_bar(stat= "mean"  )
?geom_bar
ggplot(a, aes(x = value, fill = name)) + geom_bar(stat = "summary", fun.y = "mean"  )
ggplot(a, aes(x = value, fill = name)) + geom_bar(stat = "summary", fun.x = "mean"  )
ggplot(a, aes(x = value, fill = name)) + geom_bar(stat = "summary", fun = "mean"  )
ggplot(a, aes(y = value, fill = name)) + geom_bar(stat = "summary", fun = "mean"  )
ggplot(a, aes(x = value, fill = name)) + geom_bar(stat = "summary", fun = "mean"  )
ggplot(a, aes(x = value, fill = name)) + geom_col(stat = "summary", fun = "mean"  )
ggplot(a, aes(x = value, fill = name)) + geom_bar(stat = "summary", fun = "mean"  )
ggplot(a, aes(x = name, y = value)) + geom_bar(stat = "summary", fun = "mean"  )
library(ggbeeswarm)
ggplot(a, aes(x = name, y = value)) + geom_bar(stat = "summary", fun = "mean", fill = "blue")
library(wizard)
qbeeswarm(a, name, value)
lifecycle::last_lifecycle_warnings()
qbeeswarm(a, name, value, box = F)
p1 <- ggplot(a, aes(x = name, y = value)) + geom_bar(stat = "summary",
fun = "mean", fill = "blue")
p2 <- qbeeswarm(a, name, value, box = F)
p1 + p2
library(patchwork)
p1 + p2
p1 / p2
p1
p2
p1 + p2
